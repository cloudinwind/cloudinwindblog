import{_ as t,c as i,a,o as p}from"./app-DXtwkRhK.js";const o={};function s(n,e){return p(),i("div",null,e[0]||(e[0]=[a('<h2 id="_3-1-历史观点" tabindex="-1"><a class="header-anchor" href="#_3-1-历史观点"><span>3.1 历史观点</span></a></h2><p>K ：1000</p><p>M ：1 000 000</p><p>G ：1 000 000 000</p><p>在技术讲解之前，先快速浏览 C 语言、汇编代码以及机器代码之间的关系。</p><p>然后介绍 x86-64 的细节，从数据的表示和处理以及控制的实现开始。了解如何实现 C 语言中的控制结构，如 if 、 while 和 switch 语句。之后，我们会讲到过程的实现，包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。</p><p>接着，我们会考虑在机器级如何实现像数组、结构和联合这样的数据结构。</p><p>有了这些机器级编程的背景知识，我们会讨论内存访问越界的问题，以及系统容易遭受缓冲区溢出攻击的问题。在这一部分的结尾，我们会给出一些用 GDB 调试器检查机器级程序运行时行为的技巧。</p><p>本章的最后展示了包含浮点数据和操作的代码的机器程序表示。</p><h2 id="_3-2-程序编码" tabindex="-1"><a class="header-anchor" href="#_3-2-程序编码"><span>3.2 程序编码</span></a></h2><div class="language-shell line-numbers-mode" data-ext="shell" data-title="shell"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">gcc</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -Og</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -o</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> p</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> p1.c</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> p2.c</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>编译选项 <code>-Og</code> 告诉编译器使用 会生成符合原始C语言代码整体结构的机器代码 的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。</p><br><p><code>gcc</code>命令调用了一整套的程序，将源代码转化成可执行代码。</p><p>首先， C 预处理器扩展源代码，插入所有用 <code>#include</code> 命令指定的文件，并扩展所有用 <code>#define</code> 声明指定的宏。</p><p>其次，编译器产生两个源文件的汇编代码，名字分别为 <code>p1. s</code> 和 <code>p2.s</code> 。</p><p>接下来，汇编器会将汇编代码转化成二进制目标代码文件 <code>p1.o</code> 和 <code>p2.o</code> 。 目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。</p><p>最后，链接器将两个目标代码文件与实现库函数（例如 <code>printf</code>) 的代码合并，并产生最终的可执行代码文件 p（由命令行指示符 <code>-o p</code> 指定的）。</p><h3 id="机器级代码" tabindex="-1"><a class="header-anchor" href="#机器级代码"><span>机器级代码</span></a></h3><p>对于机器级编程来说，有两种抽象极为重要：</p><ul><li>第一种是由 指令集体系结构或指令集架构 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。</li><li>第二种是 机器级程序使用的内存地址四虚拟地址，提供的内存模型看上去是一个非常大的字节数组。</li></ul><br> x86-64 的机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态 在机器代码层面是可见的： <ul><li><p><strong>程序计数器</strong>（通常称为 &quot;PC&quot;, 在 x86-64 中用 ％rip 表示）给出将要执行的下一条指令在内存中的地址。</p></li><li><p><strong>整数寄存器文件</strong>包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址 （对应于 C 语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其 他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</p></li><li><p><strong>条件码寄存器</strong>保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或 数据流中的条件变化，比如说用来实现 if 和 while 语句。</p></li><li><p>一组<strong>向量寄存器</strong>可以存放一个或多个整数或浮点数值。</p></li></ul><h3 id="代码示例" tabindex="-1"><a class="header-anchor" href="#代码示例"><span>代码示例</span></a></h3><p>gdb使用：</p>',26)]))}const c=t(o,[["render",s],["__file","CSAPP_chapter3.html.vue"]]),l=JSON.parse('{"path":"/posts/CSAPP_chapter3","title":"CSAPP","lang":"zh-CN","frontmatter":{"title":"CSAPP","createTime":"2025/08/27 12:03:01","permalink":"/posts/CSAPP_chapter3","tags":["学习","CSAPP","Linux内核"],"description":"3.1 历史观点 K ：1000 M ：1 000 000 G ：1 000 000 000 在技术讲解之前，先快速浏览 C 语言、汇编代码以及机器代码之间的关系。 然后介绍 x86-64 的细节，从数据的表示和处理以及控制的实现开始。了解如何实现 C 语言中的控制结构，如 if 、 while 和 switch 语句。之后，我们会讲到过程的实现，包括...","head":[["meta",{"property":"og:url","content":"https://cloudinwind.github.io/cloudinwindblog/cloudinwindblog/posts/CSAPP_chapter3"}],["meta",{"property":"og:site_name","content":"小风"}],["meta",{"property":"og:title","content":"CSAPP"}],["meta",{"property":"og:description","content":"3.1 历史观点 K ：1000 M ：1 000 000 G ：1 000 000 000 在技术讲解之前，先快速浏览 C 语言、汇编代码以及机器代码之间的关系。 然后介绍 x86-64 的细节，从数据的表示和处理以及控制的实现开始。了解如何实现 C 语言中的控制结构，如 if 、 while 和 switch 语句。之后，我们会讲到过程的实现，包括..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-28T11:05:09.000Z"}],["meta",{"property":"article:tag","content":"学习"}],["meta",{"property":"article:tag","content":"CSAPP"}],["meta",{"property":"article:tag","content":"Linux内核"}],["meta",{"property":"article:modified_time","content":"2025-08-28T11:05:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CSAPP\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-28T11:05:09.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":3.37,"words":1012},"git":{"updatedTime":1756379109000,"contributors":[{"name":"cloudinwind","username":"cloudinwind","email":"48953880+cloudinwind@users.noreply.github.com","commits":5,"avatar":"https://avatars.githubusercontent.com/cloudinwind?v=4","url":"https://github.com/cloudinwind"}]},"autoDesc":true,"filePathRelative":"work/CSAPP.md","categoryList":[{"id":"67e92c","sort":10000,"name":"work"}]}');export{c as comp,l as data};
