---
title: CSAPP
createTime: 2025/08/27 12:03:01
permalink: /posts/CSAPP_chapter3
tags:
- 学习
- CSAPP
- Linux内核
---

# 第三章 程序的机器级表示

## 3.1 历史观点
K ：1000

M ：1 000 000

G ：1 000 000 000

在技术讲解之前，先快速浏览 C 语言、汇编代码以及机器代码之间的关系。

然后介绍 x86-64 的细节，从数据的表示和处理以及控制的实现开始。了解如何实现 C 语言中的控制结构，如 if 、 while 和 switch 语句。之后，我们会讲到过程的实现，包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。

接着，我们会考虑在机器级如何实现像数组、结构和联合这样的数据结构。

有了这些机器级编程的背景知识，我们会讨论内存访问越界的问题，以及系统容易遭受缓冲区溢出攻击的问题。在这一部分的结尾，我们会给出一些用 GDB 调试器检查机器级程序运行时行为的技巧。

本章的最后展示了包含浮点数据和操作的代码的机器程序表示。

## 3.2 程序编码

```shell
gcc -Og -o p p1.c p2.c
```

编译选项 `-Og` 告诉编译器使用 会生成符合原始C语言代码整体结构的机器代码 的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。

<br>

`gcc`命令调用了一整套的程序，将源代码转化成可执行代码。

首先， C 预处理器扩展源代码，插入所有用 `#include` 命令指定的文件，并扩展所有用 `#define` 声明指定的宏。

其次，编译器产生两个源文件的汇编代码，名字分别为 `p1. s` 和 `p2.s` 。

接下来，汇编器会将汇编代码转化成二进制目标代码文件 `p1.o` 和 `p2.o` 。 目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。

最后，链接器将两个目标代码文件与实现库函数（例如 `printf`) 的代码合并，并产生最终的可执行代码文件 p（由命令行指示符 `-o p` 指定的）。

### 机器级代码

对于机器级编程来说，有两种抽象极为重要：

- 第一种是由 指令集体系结构或指令集架构 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
- 第二种是 机器级程序使用的内存地址四虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

<br>
x86-64 的机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态 在机器代码层面是可见的：

- **程序计数器**（通常称为 "PC", 在 x86-64 中用 ％rip 表示）给出将要执行的下一条指令在内存中的地址。

- **整数寄存器文件**包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址
（对应于 C 语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其
他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。

- **条件码寄存器**保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或
数据流中的条件变化，比如说用来实现 if 和 while 语句。

- 一组**向量寄存器**可以存放一个或多个整数或浮点数值。


### 代码示例

gdb使用：
